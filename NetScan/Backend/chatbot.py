from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import tempfile
import os
import re
import logging
from werkzeug.utils import secure_filename
import PyPDF2
import io

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

def extract_text_from_pdf(file):
    """
    Extract text from an uploaded PDF file.
    
    Args:
        file (FileStorage): Uploaded PDF file
    
    Returns:
        str: Extracted and cleaned text from the PDF
    """
    try:
        # Read the file in memory
        pdf_reader = PyPDF2.PdfReader(io.BytesIO(file.read()))
        
        # Extract text from all pages
        full_text = ""
        for page in pdf_reader.pages:
            full_text += page.extract_text() + "\n\n"
        
        # Clean up the extracted text
        full_text = clean_extracted_text(full_text)
        
        # Truncate text if it's too long
        max_text_length = 5000
        if len(full_text) > max_text_length:
            logger.warning(f"Truncating text from {len(full_text)} to {max_text_length} characters")
            full_text = full_text[:max_text_length]
        
        return full_text
    except Exception as e:
        logger.error(f"PDF text extraction error: {e}")
        return None

def clean_extracted_text(text):
    """
    Clean and format the extracted PDF text.
    
    Args:
        text (str): Raw extracted text
    
    Returns:
        str: Cleaned and formatted text
    """
    # Remove excessive whitespaces
    text = re.sub(r'\s+', ' ', text)
    
    # Remove non-printable characters
    text = re.sub(r'[^\x20-\x7E\n]', '', text)
    
    # Normalize line breaks
    text = re.sub(r'\n\s*\n', '\n\n', text)
    
    # Trim leading/trailing whitespaces
    text = text.strip()
    
    return text

@app.route('/')
def index():
    """
    Serve the main HTML file.
    
    Returns:
        Response: The NetScanner HTML file
    """
    return send_from_directory('.', 'NetScanner.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    """
    Handle PDF file upload and text extraction.
    
    Returns:
        JSON response with extracted text or error
    """
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
    
    if file and file.filename.lower().endswith('.pdf'):
        try:
            # Extract text from the PDF
            text = extract_text_from_pdf(file)
            
            if not text:
                return jsonify({'error': 'Could not extract text from PDF'}), 500
            
            return jsonify({'text': text})
        
        except Exception as e:
            logger.error(f"Upload error: {e}")
            return jsonify({'error': 'Error processing PDF'}), 500
    
    return jsonify({'error': 'File must be a PDF'}), 400

@app.route('/ask', methods=['POST'])
def process_question():
    """
    Process questions about network scan or general cybersecurity queries.
    
    Returns:
        JSON response with AI-generated answer or placeholder response
    """
    data = request.get_json()
    
    if not data or 'question' not in data:
        return jsonify({'error': 'Missing question'}), 400
    
    text = data.get('text', '')
    question = data['question']
    
    # Placeholder AI response generation
    try:
        # Simulate AI response generation
        response = generate_ai_response(text, question)
        return jsonify({'answer': response})
    
    except Exception as e:
        logger.error(f"Question processing error: {e}")
        return jsonify({'error': 'Error processing question'}), 500

def generate_ai_response(text, question):
    """
    Generate a placeholder AI response.
    
    Args:
        text (str): Context text from PDF
        question (str): User's question
    
    Returns:
        str: Generated response
    """
    # This is a placeholder implementation
    # In a real application, you would integrate with an AI API like OpenAI
    context_preview = text[:300] + '...' if text else 'No context provided'
    
    return (
        f"Simulated AI Response:\n\n"
        f"Question: {question}\n\n"
        f"Context Preview: {context_preview}\n\n"
        "Note: This is a placeholder response. In a real application, "
        "this would be generated by an AI model like GPT-4."
    )

# Error handlers
@app.errorhandler(400)
def bad_request(error):
    return jsonify({'error': 'Bad request'}), 400

@app.errorhandler(500)
def server_error(error):
    return jsonify({'error': 'Internal server error'}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)